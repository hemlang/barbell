// JSON deserialization benchmark - Hemlock

fn parse_int(s) {
    let result = 0;
    let idx = 0;
    let is_negative = false;
    if (idx < s.length) {
        let ch = s[idx];
        if (ch == '-') {
            is_negative = true;
            idx = idx + 1;
        }
    }
    while (idx < s.length) {
        let ch = s[idx];
        let code: i32 = ch;
        let zero: i32 = '0';
        let nine: i32 = '9';
        if (code < zero || code > nine) {
            break;
        }
        result = result * 10 + (code - zero);
        idx = idx + 1;
    }
    if (is_negative) {
        return -result;
    }
    return result;
}

fn int_to_string(n) {
    if (n == 0) {
        return "0";
    }
    let result = "";
    let num = n;
    let is_negative = false;
    if (num < 0) {
        is_negative = true;
        num = -num;
    }
    while (num > 0) {
        let digit = num % 10;
        let ch = "";
        if (digit == 0) { ch = "0"; }
        else if (digit == 1) { ch = "1"; }
        else if (digit == 2) { ch = "2"; }
        else if (digit == 3) { ch = "3"; }
        else if (digit == 4) { ch = "4"; }
        else if (digit == 5) { ch = "5"; }
        else if (digit == 6) { ch = "6"; }
        else if (digit == 7) { ch = "7"; }
        else if (digit == 8) { ch = "8"; }
        else if (digit == 9) { ch = "9"; }
        result = ch + result;
        num = num / 10;
    }
    if (is_negative) {
        result = "-" + result;
    }
    return result;
}

fn float_to_string(n, decimals) {
    let int_part = n;
    if (n < 0) {
        int_part = -int_part;
    }
    let frac = n - int_part;
    if (frac < 0) {
        frac = -frac;
    }

    let multiplier = 1;
    let i = 0;
    while (i < decimals) {
        multiplier = multiplier * 10;
        i = i + 1;
    }
    let frac_int = (frac * multiplier + 0.5);

    let result = int_to_string(int_part) + ".";
    let frac_str = int_to_string(frac_int);

    while (frac_str.length < decimals) {
        frac_str = "0" + frac_str;
    }

    if (n < 0) {
        return "-" + result + frac_str;
    }
    return result + frac_str;
}

// Simple JSON parser for our specific format
fn skip_whitespace(json, pos) {
    while (pos < json.length) {
        let ch = json[pos];
        if (ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r') {
            break;
        }
        pos = pos + 1;
    }
    return pos;
}

fn parse_json_string(json, pos) {
    // Skip opening quote
    pos = pos + 1;
    let result = "";
    while (pos < json.length) {
        let ch = json[pos];
        if (ch == '"') {
            pos = pos + 1;
            break;
        }
        result = result + ch;
        pos = pos + 1;
    }
    return [result, pos];
}

fn parse_json_number(json, pos) {
    let start = pos;
    let is_negative = false;
    let has_decimal = false;

    if (pos < json.length && json[pos] == '-') {
        is_negative = true;
        pos = pos + 1;
    }

    let int_part = 0;
    while (pos < json.length) {
        let ch = json[pos];
        let code: i32 = ch;
        let zero: i32 = '0';
        let nine: i32 = '9';
        if (code < zero || code > nine) {
            break;
        }
        int_part = int_part * 10 + (code - zero);
        pos = pos + 1;
    }

    let frac_part = 0.0;
    if (pos < json.length && json[pos] == '.') {
        has_decimal = true;
        pos = pos + 1;
        let divisor = 10.0;
        while (pos < json.length) {
            let ch = json[pos];
            let code: i32 = ch;
            let zero: i32 = '0';
            let nine: i32 = '9';
            if (code < zero || code > nine) {
                break;
            }
            frac_part = frac_part + (code - zero) / divisor;
            divisor = divisor * 10.0;
            pos = pos + 1;
        }
    }

    let result = int_part + frac_part;
    if (is_negative) {
        result = -result;
    }
    return [result, pos];
}

fn parse_json_array(json, pos) {
    // Skip opening bracket
    pos = pos + 1;
    let result = [];

    while (pos < json.length) {
        pos = skip_whitespace(json, pos);
        if (json[pos] == ']') {
            pos = pos + 1;
            break;
        }
        if (json[pos] == ',') {
            pos = pos + 1;
            continue;
        }

        let parsed = parse_json_number(json, pos);
        result.push(parsed[0]);
        pos = parsed[1];
    }

    return [result, pos];
}

fn parse_json_bool(json, pos) {
    if (pos + 4 <= json.length) {
        let substr = "";
        let i = 0;
        while (i < 4) {
            substr = substr + json[pos + i];
            i = i + 1;
        }
        if (substr == "true") {
            return [true, pos + 4];
        }
    }
    if (pos + 5 <= json.length) {
        let substr = "";
        let i = 0;
        while (i < 5) {
            substr = substr + json[pos + i];
            i = i + 1;
        }
        if (substr == "false") {
            return [false, pos + 5];
        }
    }
    return [false, pos];
}

fn parse_record(json) {
    let id = 0;
    let name = "";
    let value = 0.0;
    let active = false;
    let tags = [];

    let pos = skip_whitespace(json, 0);
    if (json[pos] != '{') {
        return [id, name, value, active, tags];
    }
    pos = pos + 1;

    while (pos < json.length && json[pos] != '}') {
        pos = skip_whitespace(json, pos);
        if (json[pos] == ',') {
            pos = pos + 1;
            continue;
        }
        if (json[pos] != '"') {
            break;
        }

        // Parse key
        let key_result = parse_json_string(json, pos);
        let key = key_result[0];
        pos = key_result[1];

        pos = skip_whitespace(json, pos);
        if (json[pos] != ':') {
            break;
        }
        pos = pos + 1;
        pos = skip_whitespace(json, pos);

        // Parse value based on key
        if (key == "id") {
            let parsed = parse_json_number(json, pos);
            id = parsed[0];
            pos = parsed[1];
        } else if (key == "name") {
            let parsed = parse_json_string(json, pos);
            name = parsed[0];
            pos = parsed[1];
        } else if (key == "value") {
            let parsed = parse_json_number(json, pos);
            value = parsed[0];
            pos = parsed[1];
        } else if (key == "active") {
            let parsed = parse_json_bool(json, pos);
            active = parsed[0];
            pos = parsed[1];
        } else if (key == "tags") {
            let parsed = parse_json_array(json, pos);
            tags = parsed[0];
            pos = parsed[1];
        }
    }

    return [id, name, value, active, tags];
}

let n = 100000;
if (args.length > 1) {
    n = parse_int(args[1]);
}

let total_id = 0;
let i = 0;

while (i < n) {
    let json_str = "{\"id\":" + int_to_string(i) + ",\"name\":\"benchmark_test\",\"value\":" + float_to_string(3.14159 + (i % 100) * 0.001, 6) + ",\"active\":true,\"tags\":[1,2,3,4,5]}";
    let record = parse_record(json_str);
    total_id = total_id + record[0];
    i = i + 1;
}

print(total_id);
